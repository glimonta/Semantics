theory tmpl5_1
imports "~~/src/HOL/IMP/Big_Step"
begin

(**
  Template for homework 5.1.

  Replace all the "sorry"s and oops by valid proofs!
**)

text {* 
\NumHomework{Fuel your executions}{November 18, 2014}
  Note: We provide a template for this homework on the lecture's homepage.

  If you try to define a function to execute a program,
  you will run into trouble with the termination proof (The program might 
  not terminate).

  In this exercise, you will define an execution function that tries to execute
  the program for a bounded number of steps. It gets an additional 
  @{typ nat} argument, called fuel, which decreases in every step. If 
  the execution runs out of fuel, it stops returning @{term None}.
*}

fun exec :: "com \<Rightarrow> state \<Rightarrow> nat \<Rightarrow> state option" where
  "exec _ s 0 = None" 
| "exec SKIP s (Suc f) = Some s" 
| "exec (x::=v) s (Suc f) = Some (s(x:=aval v s))" 
| "exec (c1;;c2) s (Suc f) = (
    case (exec c1 s f) of None \<Rightarrow> None | Some s' \<Rightarrow> exec c2 s' f)" 
| "exec (IF b THEN c1 ELSE c2) s (Suc f) = 
    (if bval b s then exec c1 s f else exec c2 s f)" 
| "exec (WHILE b DO c) s (Suc f) = (
    if bval b s then 
      (case (exec c s f) of 
        None \<Rightarrow> None | 
        Some s' \<Rightarrow> exec (WHILE b DO c) s' f) 
    else Some s)"


text {* The two directions are proved separately. The proof of the first 
  direction should be quite straightforward, and is left to you. *}
lemma exec_imp_bigstep: "exec c s f = Some s' \<Longrightarrow> (c,s) \<Rightarrow> s'"
  sorry

text {*
  For the other direction, prove a monotonicity lemma first:
  If the execution terminates with fuel @{text "f"}, it terminates
  with the same result using a larger amount of fuel @{text "f+k"}.
*}
lemma exec_mono: "exec c s f = Some s' \<Longrightarrow> exec c s (f+k) = Some s'"
proof (induction c s f arbitrary: s'
    rule: exec.induct[case_names None SKIP ASS SEMI IF WHILE])
  -- \<open>Note: The @{text case_names} attribute assigns (new) names to the cases
      generated by the induction rule, that can then be used with the 
      @{text case} - command, as done below. \<close>
  case (WHILE b c s i s') thus ?case
    txt {* Only the WHILE-case requires some effort. Hint: Make a
      case distinction on the value of the condition @{text "b"}. *}
      sorry
qed (auto split: option.split option.split_asm)

text {*
  The main lemma is proved by induction over the big-step semantics. Remember
  the adapted induction rule @{text "big_step_induct"} that nicely handles the
  pattern @{text "big_step (c,s) s'"}.
*}
lemma bigstep_imp_si:
  "(c,s) \<Rightarrow> s' \<Longrightarrow> \<exists>k. exec c s k = Some s'"
proof (induct rule: big_step_induct)
  txt {* We demonstrate the skip, while-true and sequential composition case 
    here. The other cases are left to you! *}
  case (Skip s) have "exec SKIP s 1 = Some s" by auto
  thus ?case by blast
next
  case (WhileTrue b s1 c s2 s3)
  then obtain f1 f2 where "exec c s1 f1 = Some s2" 
    and "exec (WHILE b DO c) s2 f2 = Some s3" by auto
  with exec_mono[of c s1 f1 s2 f2] 
    exec_mono[of "WHILE b DO c" s2 f2 s3 f1] have 
    "exec c s1 (f1+f2) = Some s2" 
    and "exec (WHILE b DO c) s2 (f2+f1) = Some s3"
    by auto
  hence "exec (WHILE b DO c) s1 (Suc (f1+f2)) = Some s3" 
    using `bval b s1` by (auto simp add: add_ac)
  thus ?case by blast
next
  case (Seq c1 s1 s2 c2 s3)
  then obtain f1 f2 where "exec c1 s1 f1 = Some s2" and "exec c2 s2 f2 = Some s3"
    by auto
  with exec_mono[of c1 s1 f1 s2 f2] 
    exec_mono[of c2 s2 f2 s3 f1] 
  have 
    "exec c1 s1 (f1+f2) = Some s2" and "exec c2 s2 (f2+f1) = Some s3"
    by auto
  hence "exec (c1;;c2) s1 (Suc (f1+f2)) = Some s3" by (auto simp add: add_ac)
  thus ?case by blast
next
  case (Assign x a s)
next
  case (IfTrue b s c1 t c2)
next
  case (IfFalse b s c2 t c1)
next
  case (WhileFalse b s c) 
oops

text {* Finally, prove the main theorem of the homework: *}
theorem exec_equiv_bigstep: "(\<exists>k. exec c s k = Some s') \<longleftrightarrow> (c,s) \<Rightarrow> s'"
  oops

end
